--- LSPhORS.Mod.txt
+++ LSPhORS.Mod.txt
@@ -1,5 +1,5 @@
-MODULE ORS; (* NW 19.9.93 / 20.3.2017  Scanner in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
-  IMPORT SYSTEM, Texts, Oberon;
+MODULE LSPhORS; (* NW 19.9.93 / 20.3.2017  Scanner in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
+  IMPORT SYSTEM, Texts, Oberon, RS232, LSPhConstants;
 
 (* Oberon Scanner does lexical analysis. Input is Oberon-Text, output is
   sequence of symbols, i.e identifiers, numbers, strings, and special symbols.
@@ -29,9 +29,10 @@
     to* = 51; by* = 52; semicolon* = 53; bar* = 54; end* = 55;
     else* = 56; elsif* = 57; until* = 58;
     array* = 60; record* = 61; pointer* = 62; const* = 63; type* = 64;
-    var* = 65; procedure* = 66; begin* = 67; import* = 68; module* = 69; final* = 70; eot = 71;
+    var* = 65; procedure* = 66; begin* = 67; import* = 68; module* = 69; final* = 70; eot* = 71;
 
   TYPE Ident* = ARRAY IdLen OF CHAR;
+    Callback* = PROCEDURE(tag, beg, end, value: INTEGER);
 
   VAR ival*, slen*: LONGINT;  (*results of Get*)
     rval*: REAL;
@@ -42,7 +43,10 @@
     ch: CHAR;  (*last character read*)
     errpos: LONGINT;
     R: Texts.Reader;
-    W: Texts.Writer;
+    lspMode*: INTEGER;
+    callback: Callback;
+    syntaxType, formatType: ARRAY eot+1 OF INTEGER;
+    lastIdentStart: INTEGER;
     k: INTEGER;
     KWX: ARRAY 10 OF INTEGER;
     keyTab: ARRAY NKW OF
@@ -59,9 +63,10 @@
   PROCEDURE Mark*(msg: ARRAY OF CHAR);
     VAR p: LONGINT;
   BEGIN p := Pos();
-    IF (p > errpos) & (errcnt < 25) THEN
-      Texts.WriteLn(W); Texts.WriteString(W, "  pos "); Texts.WriteInt(W, p, 1); Texts.Write(W, " ");
-      Texts.WriteString(W, msg); Texts.Append(Oberon.Log, W.buf)
+    IF (p > errpos) & (errcnt < 500) & (lspMode = LSPhConstants.GetModuleInfo) THEN
+      RS232.Send(LSPhConstants.Error);
+      RS232.SendIntRaw(p);
+      RS232.SendStrRaw(msg)
     END ;
     INC(errcnt); errpos := p + 4
   END Mark;
@@ -72,7 +77,7 @@
     REPEAT
       IF i < IdLen-1 THEN id[i] := ch; INC(i) END ;
       Texts.Read(R, ch)
-    UNTIL (ch < "0") OR (ch > "9") & (ch < "A") OR (ch > "Z") & (ch < "a") OR (ch > "z");
+    UNTIL (ch < "0") & ((lspMode # LSPhConstants.AutoComplete) OR (ch # 3X)) OR (ch > "9") & (ch < "A") OR (ch > "Z") & (ch < "a") OR (ch > "z");
     id[i] := 0X; 
     IF i < 10 THEN k := KWX[i-1];  (*search for keyword*)
       WHILE (id # keyTab[k].id) & (k < KWX[i]) DO INC(k) END ;
@@ -192,24 +197,135 @@
     END
   END Number;
 
-  PROCEDURE comment;
-  BEGIN Texts.Read(R, ch);
+  PROCEDURE SetMode* (m: INTEGER; cb: Callback);
+  BEGIN lspMode := m; callback := cb;
+  END SetMode;
+
+  PROCEDURE ModuleTag*(tag: INTEGER);
+  BEGIN
+    IF lspMode = LSPhConstants.GetModuleInfo THEN RS232.Send(tag) END
+  END ModuleTag;
+
+  PROCEDURE ModuleTagH*(tag: INTEGER);
+  BEGIN
+    IF lspMode = LSPhConstants.HighlightCallback THEN
+      callback(tag, -1, -1, -1)
+    ELSE ModuleTag(tag) END
+  END ModuleTagH;
+
+  PROCEDURE ModuleTagPP*(tag, pos: INTEGER);
+  BEGIN
+    IF lspMode = LSPhConstants.GetModuleInfo THEN RS232.Send(tag); RS232.SendIntRaw(pos) END
+  END ModuleTagPP;
+
+  PROCEDURE ModuleTagP*(tag: INTEGER);
+  BEGIN ModuleTagPP(tag, Pos())
+  END ModuleTagP;
+
+  PROCEDURE FormatTokenTag*(tag: INTEGER);
+  BEGIN
+    IF lspMode = LSPhConstants.ReFormat THEN RS232.Send(tag)
+    ELSIF lspMode = LSPhConstants.FormatCallback THEN callback(tag, -1, -1, -1) END
+  END FormatTokenTag;
+
+  PROCEDURE FormatTokenUpdate*(type: INTEGER);
+  BEGIN
+    IF lspMode = LSPhConstants.ReFormat THEN
+      RS232.Send(LSPhConstants.FormatTokenUpdate);
+      RS232.Send(type);
+    ELSIF lspMode = LSPhConstants.FormatCallback THEN
+      callback(LSPhConstants.FormatTokenUpdate, -1, -1, type)
+    END
+  END FormatTokenUpdate;
+
+  PROCEDURE ClassifyIdent*(syntaxType, defPos: INTEGER; defModName: ARRAY OF CHAR);
+  BEGIN
+    IF lspMode = LSPhConstants.GetModuleInfo THEN
+      ASSERT(lastIdentStart # -1);
+      RS232.Send(LSPhConstants.SyntaxElement);
+      RS232.SendIntRaw(lastIdentStart);
+      RS232.SendIntRaw(Pos());
+      RS232.Send(syntaxType);
+      IF defPos = -1 THEN
+        RS232.SendIntRaw(-1);
+      ELSE
+        RS232.SendIntRaw(defPos);
+        RS232.SendStrRaw(defModName);
+      END;
+      lastIdentStart := -1
+    ELSIF lspMode = LSPhConstants.HighlightCallback THEN
+      ASSERT(lastIdentStart # -1);
+      callback(LSPhConstants.SyntaxElement,lastIdentStart,Pos(),syntaxType);
+      lastIdentStart := -1
+    END
+  END ClassifyIdent;
+
+  PROCEDURE SymbolFileIndex*(index, defEndPos: INTEGER; defModName: ARRAY OF CHAR);
+  BEGIN
+    IF lspMode = LSPhConstants.GetModuleInfo THEN
+      RS232.Send(LSPhConstants.SymbolFileIndex);
+      RS232.SendIntRaw(index);
+      RS232.SendStrRaw(defModName);
+      RS232.SendIntRaw(defEndPos);
+    END
+  END SymbolFileIndex;
+
+  PROCEDURE AddCompletion*(syntaxType: INTEGER; suggestion: ARRAY OF CHAR);
+    VAR i: INTEGER;
+  BEGIN
+    IF lspMode = LSPhConstants.AutoComplete THEN
+      i := 0; WHILE (suggestion[i] # 0X) & (suggestion[i] = id[i]) DO INC(i) END;
+      IF (id[i] = 3X) & (id[i+1] = 0X) THEN
+        RS232.Send(LSPhConstants.Completion);
+        RS232.Send(syntaxType);
+        RS232.SendStrRaw(suggestion);
+      END
+    END
+  END AddCompletion;
+
+  PROCEDURE comment(nested: BOOLEAN);
+    VAR begpos: INTEGER;
+  BEGIN Texts.Read(R, ch); begpos := Pos() - 2;
     REPEAT
       WHILE ~R.eot & (ch # "*") DO
         IF ch = "(" THEN Texts.Read(R, ch);
-          IF ch = "*" THEN comment END
+          IF ch = "*" THEN comment(TRUE) END
         ELSE Texts.Read(R, ch)
         END
       END ;
       WHILE ch = "*" DO Texts.Read(R, ch) END
     UNTIL (ch = ")") OR R.eot;
-    IF ~R.eot THEN Texts.Read(R, ch) ELSE Mark("unterminated comment") END
+    IF ~nested & (lspMode = LSPhConstants.GetModuleInfo) THEN
+      RS232.Send(LSPhConstants.SyntaxElement);
+      RS232.SendIntRaw(begpos);
+      RS232.SendIntRaw(Pos() + 1);
+      RS232.Send(LSPhConstants.SynComment);
+      RS232.SendIntRaw(-1);
+    ELSIF ~nested & (lspMode = LSPhConstants.ReFormat) THEN
+      RS232.Send(LSPhConstants.FormatToken);
+      RS232.SendIntRaw(begpos);
+      RS232.SendIntRaw(Pos() + 1);
+      RS232.Send(99);
+      RS232.Send(LSPhConstants.TokenIsComment);
+    ELSIF ~nested & (lspMode = LSPhConstants.HighlightCallback) THEN
+      callback(LSPhConstants.SyntaxElement, begpos, Pos() + 1, LSPhConstants.SynComment);
+    ELSIF ~nested & (lspMode = LSPhConstants.FormatCallback) THEN
+      callback(LSPhConstants.FormatToken, begpos, Pos() + 1, 99);
+      callback(LSPhConstants.TokenIsComment, -1, -1, -1)
+    END;
+    IF ~R.eot THEN Texts.Read(R, ch) ELSIF ~nested THEN Mark("unterminated comment") END
   END comment;
 
   PROCEDURE Get*(VAR sym: INTEGER);
+    VAR begpos: INTEGER;
   BEGIN
+    IF lastIdentStart # -1 THEN
+      Mark("LSP: Unclassified identifier");
+      lastIdentStart := -1
+    END;
     REPEAT
-      WHILE ~R.eot & (ch <= " ") DO Texts.Read(R, ch) END;
+      WHILE ~R.eot & (ch <= " ") & ((lspMode # LSPhConstants.AutoComplete) OR (ch # 3X)) DO Texts.Read(R, ch) END;
+      begpos := Pos();
       IF R.eot THEN sym := eot
       ELSIF ch < "A" THEN
         IF ch < "0" THEN
@@ -218,7 +334,7 @@
           ELSIF ch = "$" THEN HexString; sym := string
           ELSIF ch = "&" THEN Texts.Read(R, ch); sym := and
           ELSIF ch = "(" THEN Texts.Read(R, ch); 
-            IF ch = "*" THEN sym := null; comment ELSE sym := lparen END
+            IF ch = "*" THEN sym := null; comment(FALSE) ELSE sym := lparen END
           ELSIF ch = ")" THEN Texts.Read(R, ch); sym := rparen
           ELSIF ch = "*" THEN Texts.Read(R, ch); sym := times
           ELSIF ch = "+" THEN Texts.Read(R, ch); sym := plus
@@ -227,6 +343,8 @@
           ELSIF ch = "." THEN Texts.Read(R, ch);
             IF ch = "." THEN Texts.Read(R, ch); sym := upto ELSE sym := period END
           ELSIF ch = "/" THEN Texts.Read(R, ch); sym := rdiv
+          ELSIF (lspMode = LSPhConstants.AutoComplete) & (ch = 3X) THEN
+            Identifier(sym)
           ELSE Texts.Read(R, ch); (* ! % ' *) sym := null
           END
         ELSIF ch < ":" THEN Number(sym)
@@ -259,17 +377,70 @@
         Texts.Read(R, ch)
       END
     UNTIL sym # null
+    ;IF lspMode = LSPhConstants.GetModuleInfo THEN
+      IF sym = ident THEN
+        lastIdentStart := begpos;
+      ELSIF syntaxType[sym] # 0 THEN
+        RS232.Send(LSPhConstants.SyntaxElement);
+        RS232.SendIntRaw(begpos);
+        RS232.SendIntRaw(Pos());
+        RS232.Send(syntaxType[sym]);
+        RS232.SendIntRaw(-1);
+      END
+    ELSIF lspMode = LSPhConstants.HighlightCallback THEN
+      IF sym = ident THEN
+        lastIdentStart := begpos;
+      ELSIF syntaxType[sym] # 0 THEN
+        callback(LSPhConstants.SyntaxElement, begpos, Pos(), syntaxType[sym]);
+      END
+    ELSIF (lspMode = LSPhConstants.ReFormat) & (formatType[sym] # 100) THEN
+      RS232.Send(LSPhConstants.FormatToken);
+      RS232.SendIntRaw(begpos);
+      RS232.SendIntRaw(Pos());
+      RS232.Send(formatType[sym]);
+    ELSIF (lspMode = LSPhConstants.FormatCallback) & (formatType[sym] # 100) THEN
+      callback(LSPhConstants.FormatToken, begpos, Pos(), formatType[sym])
+    END;
   END Get;
 
   PROCEDURE Init*(T: Texts.Text; pos: LONGINT);
-  BEGIN errpos := pos; errcnt := 0; Texts.OpenReader(R, T, pos); Texts.Read(R, ch)
+  BEGIN errpos := pos - 1; lastIdentStart := -1; errcnt := 0; Texts.OpenReader(R, T, pos); Texts.Read(R, ch)
   END Init;
 
   PROCEDURE EnterKW(sym: INTEGER; name: ARRAY OF CHAR);
   BEGIN keyTab[k].id := name; keyTab[k].sym := sym; INC(k)
+    ;syntaxType[sym] := LSPhConstants.SynKeyword
   END EnterKW;
 
-BEGIN Texts.OpenWriter(W); k := 0; KWX[0] := 0; KWX[1] := 0;
+BEGIN KWX[0] := 0; KWX[1] := 0;
+  FOR k := 0 TO eot DO syntaxType[k] := 0; formatType[k] := 11 END;
+  formatType[null] := 100;
+  formatType[eot] := 100;
+  formatType[arrow] := 08;
+  formatType[period] := 00;
+  formatType[char] := 99;
+  formatType[int] := 99;
+  formatType[real] := 99;
+  formatType[false] := 99;
+  formatType[true] := 99;
+  formatType[nil] := 99;
+  formatType[string] := 99;
+  formatType[not] := 10;
+  formatType[lparen] := 90;
+  formatType[lbrak] := 00;
+  formatType[lbrace] := 10;
+  formatType[ident] := 99;
+  formatType[comma] := 01;
+  formatType[colon] := 01;
+  formatType[rparen] := 09;
+  formatType[rbrak] := 09;
+  formatType[rbrace] := 01;
+  formatType[semicolon] := 01;
+  formatType[const] := 21;
+  formatType[type] := 21;
+  formatType[begin] := 21;
+  formatType[var] := 91;
+  k := 0; lastIdentStart := -1;
   EnterKW(if, "IF");
   EnterKW(do, "DO");
   EnterKW(of, "OF");
@@ -312,6 +483,33 @@
   KWX[6] := k;
   EnterKW(pointer, "POINTER");
   KWX[7] := k; KWX[8] := k;
+  syntaxType[times] := LSPhConstants.SynOperator;
+  syntaxType[rdiv] := LSPhConstants.SynOperator;
+  syntaxType[div] := LSPhConstants.SynOperator;
+  syntaxType[mod] := LSPhConstants.SynOperator;
+  syntaxType[and] := LSPhConstants.SynOperator;
+  syntaxType[plus] := LSPhConstants.SynOperator;
+  syntaxType[minus] := LSPhConstants.SynOperator;
+  syntaxType[or] := LSPhConstants.SynOperator;
+  syntaxType[eql] := LSPhConstants.SynOperator;
+  syntaxType[neq] := LSPhConstants.SynOperator;
+  syntaxType[lss] := LSPhConstants.SynOperator;
+  syntaxType[leq] := LSPhConstants.SynOperator;
+  syntaxType[gtr] := LSPhConstants.SynOperator;
+  syntaxType[geq] := LSPhConstants.SynOperator;
+  syntaxType[in] := LSPhConstants.SynOperator;
+  syntaxType[is] := LSPhConstants.SynOperator;
+  syntaxType[arrow] := LSPhConstants.SynOperator;
+  syntaxType[period] := LSPhConstants.SynOperator;
+  syntaxType[char] := LSPhConstants.SynType;
+  syntaxType[int] := LSPhConstants.SynType;
+  syntaxType[real] := LSPhConstants.SynType;
+  syntaxType[false] := LSPhConstants.SynConstant;
+  syntaxType[true] := LSPhConstants.SynConstant;
+  syntaxType[nil] := LSPhConstants.SynConstant;
+  syntaxType[string] := LSPhConstants.SynString;
+  syntaxType[not] := LSPhConstants.SynOperator;
+  syntaxType[upto] := LSPhConstants.SynOperator;
   EnterKW(procedure, "PROCEDURE");
   KWX[9] := k
-END ORS.
+END LSPhORS.
--- LSPhORB.Mod.txt
+++ LSPhORB.Mod.txt
@@ -1,5 +1,5 @@
-MODULE ORB;   (*NW 25.6.2014  / AP 4.3.2020 / 5.3.2019  in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
-  IMPORT Files, ORS;
+MODULE LSPhORB;   (*NW 25.6.2014  / AP 4.3.2020 / 5.3.2019  in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
+  IMPORT Files, LSPhConstants, ORS := LSPhORS;
   (*Definition of data types Object and Type, which together form the data structure
     called "symbol table". Contains procedures for creation of Objects, and for search:
     NewObj, this, thisimport, thisfield (and OpenScope, CloseScope).
@@ -23,12 +23,12 @@
     Type* = POINTER TO TypeDesc;
 
     ObjDesc*= RECORD
-      class*, exno*: BYTE;
-      expo*, rdo*: BOOLEAN;  (*exported / read-only*)
-      lev*: INTEGER;
+      class*, lspClass*, exno*: BYTE;
+      expo*, rdo*: BOOLEAN;   (*exported / read-only*)
+      lev*, defEndPos*: INTEGER;
       next*, dsc*: Object;
       type*: Type;
-      name*: ORS.Ident;
+      name*, defModId*: ORS.Ident;
       val*: LONGINT
     END ;
 
@@ -69,12 +69,26 @@
     nofmod, Ref: INTEGER;
     typtab: ARRAY maxTypTab OF Type;
 
-  PROCEDURE NewObj*(VAR obj: Object; id: ORS.Ident; class: INTEGER);  (*insert new Object with name id*)
+  PROCEDURE SymbolMatch(VAR obj: Object);
+  BEGIN
+    IF obj = NIL THEN
+      ORS.ClassifyIdent(LSPhConstants.SynUndefined, -1, "")
+    ELSE
+      ORS.ClassifyIdent(obj.lspClass, obj.defEndPos, obj.defModId)
+    END
+  END SymbolMatch;
+
+  PROCEDURE SymbolMisMatch(VAR obj: Object);
+  BEGIN ORS.AddCompletion(obj.lspClass, obj.name)
+  END SymbolMisMatch;
+
+  PROCEDURE NewObj*(VAR obj: Object; id, modid: ORS.Ident; class, lspClass: INTEGER);  (*insert new Object with name id*)
     VAR new, x: Object;
   BEGIN x := topScope;
     WHILE (x.next # NIL) & ((x.next.name # id) OR (x.next.class = Mod) & ~x.next.rdo) DO x := x.next END ;
     IF x.next = NIL THEN
       NEW(new); new.name := id; new.class := class; new.next := NIL; new.rdo := FALSE; new.dsc := NIL;
+      new.lspClass := lspClass; new.defEndPos := ORS.Pos(); new.defModId := modid;
       x.next := new; obj := new
     ELSE obj := x.next; ORS.Mark("mult def")
     END
@@ -91,9 +105,10 @@
     VAR s, x: Object;
   BEGIN s := topScope;
     REPEAT x := s.next;
-      WHILE (x # NIL) & ((x.name # ORS.id) OR (x.class = Mod) & ~x.rdo) DO x := x.next END ;
+      WHILE (x # NIL) & ((x.name # ORS.id) OR (x.class = Mod) & ~x.rdo) DO SymbolMisMatch(x); x := x.next END ;
       s := s.dsc
     UNTIL (x # NIL) OR (s = NIL);
+    SymbolMatch(x);
     RETURN x
   END thisObj;
 
@@ -102,16 +117,18 @@
   BEGIN
     IF mod.rdo & (mod.name[0] # 0X) THEN
       obj := mod.dsc;
-      WHILE (obj # NIL) & (obj.name # ORS.id) DO obj := obj.next END
+      WHILE (obj # NIL) & (obj.name # ORS.id) DO SymbolMisMatch(obj); obj := obj.next END
     ELSE obj := NIL
     END ;
+    SymbolMatch(obj);
     RETURN obj
   END thisimport;
 
   PROCEDURE thisfield*(rec: Type): Object;
     VAR fld: Object;
   BEGIN fld := rec.dsc;
-    WHILE (fld # NIL) & (fld.name # ORS.id) DO fld := fld.next END ;
+    WHILE (fld # NIL) & (fld.name # ORS.id) DO SymbolMisMatch(fld); fld := fld.next END ;
+    SymbolMatch(fld);
     RETURN fld
   END thisfield;
 
@@ -134,7 +151,7 @@
     RETURN max + 1
   END NofMethods;
 
-  PROCEDURE NewMethod*(rec: Type; VAR mth, redef: Object; id: ORS.Ident);  (*insert new method with name id*)
+  PROCEDURE NewMethod*(rec: Type; VAR mth, redef: Object; id, modid: ORS.Ident; defEndPos: INTEGER);  (*insert new method with name id*)
     VAR fld, fld0, new, bot: Object;
 
     PROCEDURE UpdateLinks(rec: Type; new, bot: Object);  (*between field lists of extensions*)
@@ -160,6 +177,7 @@
       WHILE (fld # NIL) & (fld.name # id) DO fld := fld.next END ;  (*search id in fields of base types of rec*)
       IF (fld = NIL) OR (fld.class = Const) THEN
         NEW(new); new.name := id; new.class := Const; new.rdo := FALSE; new.dsc := NIL; new.next := bot; mth := new;
+        new.lspClass := LSPhConstants.SynProcedure; new.defEndPos := defEndPos; new.defModId := modid;
         IF fld = NIL THEN new.lev := NofMethods(rec) ELSE new.lev := fld.lev; redef := fld END ;  (*mthno*)
         IF rec.dsc = bot THEN rec.dsc := new; UpdateLinks(rec, new, bot) ELSE fld0.next := new END
       ELSE mth := fld; ORS.Mark("mult def")
@@ -186,8 +204,8 @@
     REPEAT FName[i]:= ext[j]; INC(i); INC(j) UNTIL ext[j] = 0X;
     FName[i] := 0X
   END MakeFileName;
 
-  PROCEDURE ThisModule(name, orgname: ORS.Ident; decl: BOOLEAN; key: LONGINT): Object;
+  PROCEDURE ThisModule(name, orgname, defModId: ORS.Ident; decl: BOOLEAN; defEndPos, key: LONGINT): Object;
     VAR mod: Module; obj, obj1: Object;
   BEGIN obj1 := topScope; obj := obj1.next;  (*search for module*)
     WHILE (obj # NIL) & (obj(Module).orgname # orgname) DO obj1 := obj; obj := obj1.next END ;
@@ -198,6 +216,7 @@
       END ;
       IF obj = NIL THEN (*insert new module*)
         NEW(mod); mod.class := Mod; mod.rdo := FALSE;
+        mod.lspClass := LSPhConstants.SynModule; mod.defEndPos := defEndPos; mod.defModId := defModId;
         mod.name := name; mod.orgname := orgname; mod.val := key;
         mod.lev := nofmod; INC(nofmod); mod.type := noType; mod.dsc := NIL; mod.next := NIL;
         obj1.next := mod; obj := mod
@@ -238,7 +257,9 @@
           NEW(fld); fld.class := class; Files.ReadString(R, fld.name);
           IF last = NIL THEN t.dsc := fld ELSE last.next := fld END ;
           last := fld;
-          IF fld.name[0] # 0X THEN fld.expo := TRUE; InType(R, thismod, fld.type); Files.ReadNum(R, fld.val)
+          IF fld.name[0] # 0X THEN
+            Read(R, key); fld.lspClass := key; Files.ReadString(R, fld.defModId); IF fld.defModId = "^" THEN fld.defModId := thismod(Module).orgname END; Files.ReadInt(R, fld.defEndPos);
+            fld.expo := TRUE; InType(R, thismod, fld.type); Files.ReadNum(R, fld.val)
           ELSE (*hidden*) fld.expo := FALSE;
             IF class = Const THEN (*type-bound procedure*) fld.type := byteType  (*method*)
             ELSE Files.ReadNum(R, fld.val);
@@ -263,12 +284,13 @@
       Files.ReadString(R, modname);
       IF modname[0] #  0X THEN  (*re-import*)
         Files.ReadInt(R, key); Files.ReadString(R, name);
-        mod := ThisModule(modname, modname, FALSE, key);
+        mod := ThisModule(modname, modname, modname, FALSE, -1, key);
         obj := mod.dsc;  (*search type*)
         WHILE (obj # NIL) & (obj.name # name) DO obj := obj.next END ;
         IF obj # NIL THEN T := obj.type   (*type object found in object list of mod*)
         ELSE (*insert new type object in object list of mod*)
           NEW(obj); obj.name := name; obj.class := Typ; obj.next := mod.dsc; mod.dsc := obj; obj.type := t;
+          obj.lspClass := LSPhConstants.SynType; obj.defEndPos := -1;
           t.mno := mod.lev; t.typobj := obj; T := t
         END ;
         typtab[ref] := T
@@ -276,24 +298,25 @@
     END
   END InType;
 
-  PROCEDURE Import*(VAR modid, modid1: ORS.Ident);
+  PROCEDURE Import*(VAR modid, modid1, thisModId: ORS.Ident; defEndPos: INTEGER);
     VAR key: LONGINT; class, k: INTEGER;
       obj, thismod: Object; t: Type;
       modname, fname: ORS.Ident;
       F: Files.File; R: Files.Rider;
   BEGIN
     IF modid1 = "SYSTEM" THEN
-      thismod := ThisModule(modid, modid1, TRUE, key); DEC(nofmod);
+      thismod := ThisModule(modid, modid1, thisModId, TRUE, defEndPos,  key); DEC(nofmod);
       thismod.lev := 0; thismod.dsc := system; thismod.rdo := TRUE
-    ELSE MakeFileName(fname, modid1, ".smb"); F := Files.Old(fname);
+    ELSE MakeFileName(fname, modid1, ".smL"); F := Files.Old(fname);
       IF F # NIL THEN
         Files.Set(R, F, 0); Files.ReadInt(R, key); Files.ReadInt(R, key); Files.ReadString(R, modname);
-        thismod := ThisModule(modid, modid1, TRUE, key); thismod.rdo := TRUE;
+        thismod := ThisModule(modid, modid1, thisModId, TRUE, defEndPos, key); thismod.rdo := TRUE;
         Read(R, class); (*version key*)
         IF class # versionkey THEN ORS.Mark("wrong version") END ;
         Read(R, class);
         WHILE class # 0 DO
           NEW(obj); obj.class := class; Files.ReadString(R, obj.name);
+          Read(R, k); obj.lspClass := k; Files.ReadString(R, obj.defModId); IF obj.defModId = "^" THEN obj.defModId := modid1 END; Files.ReadInt(R, obj.defEndPos);
           InType(R, thismod, obj.type); obj.lev := -thismod.lev;
           IF class = Typ THEN
             t := obj.type; t.typobj := obj; Read(R, k);  (*fixup bases of previously declared pointer types*)
@@ -315,17 +338,17 @@
   BEGIN Files.WriteByte(R, x)  (* -128 <= x < 128 *)
   END Write;
 
-  PROCEDURE OutType(VAR R: Files.Rider; t: Type);
+  PROCEDURE OutType(VAR R: Files.Rider; VAR modid: ORS.Ident; t: Type);
     VAR obj, mod, fld, bot: Object;
 
-    PROCEDURE OutPar(VAR R: Files.Rider; par: Object; n: INTEGER);
+    PROCEDURE OutPar(VAR R: Files.Rider; VAR modid: ORS.Ident; par: Object; n: INTEGER);
       VAR cl: INTEGER;
     BEGIN
       IF n > 0 THEN
-        OutPar(R, par.next, n-1); cl := par.class;
+        OutPar(R, modid, par.next, n-1); cl := par.class;
         Write(R, cl);
         IF par.rdo THEN Write(R, 1) ELSE Write(R, 0) END ;
-        OutType(R, par.type)
+        OutType(R, modid, par.type)
       END
     END OutPar;
 
@@ -346,10 +369,10 @@
     ELSE obj := t.typobj;
       IF obj # NIL THEN Write(R, Ref); t.ref := Ref; INC(Ref) ELSE (*anonymous*) Write(R, 0) END ;
       Write(R, t.form);
-      IF t.form = Pointer THEN OutType(R, t.base)
-      ELSIF t.form = Array THEN OutType(R, t.base); Files.WriteNum(R, t.len); Files.WriteNum(R, t.size)
+      IF t.form = Pointer THEN OutType(R, modid, t.base)
+      ELSIF t.form = Array THEN OutType(R, modid, t.base); Files.WriteNum(R, t.len); Files.WriteNum(R, t.size)
       ELSIF t.form = Record THEN
-        IF t.base # NIL THEN OutType(R, t.base); bot := t.base.dsc ELSE OutType(R, noType); bot := NIL END ;
+        IF t.base # NIL THEN OutType(R, modid, t.base); bot := t.base.dsc ELSE OutType(R, modid, noType); bot := NIL END ;
         IF obj # NIL THEN
           IF t.mno > 0 THEN Files.WriteNum(R, t.len) ELSE Files.WriteNum(R, obj.exno) END
         ELSE Write(R, 0)
@@ -358,19 +381,21 @@
         fld := t.dsc;
         WHILE fld # bot DO  (*fields*)
           IF fld.class = Const THEN (*type-bound procedure*) Write(R, Const);
-            IF fld.expo THEN Files.WriteString(R, fld.name); OutType(R, fld.type);
+            IF fld.expo THEN Files.WriteString(R, fld.name); OutType(R, modid, fld.type);
               IF t.mno > 0 THEN Files.WriteNum(R, fld.val) ELSE Files.WriteNum(R, fld.exno) END  (*exno*)
             ELSE (*hidden*) Write(R, 0)
             END ;
             Files.WriteNum(R, fld.lev)  (*mthno*)
           ELSIF fld.expo THEN
-            Write(R, Fld); Files.WriteString(R, fld.name); OutType(R, fld.type); Files.WriteNum(R, fld.val)  (*offset*)
+            Write(R, Fld); Files.WriteString(R, fld.name);
+            Write(R, fld.lspClass); IF fld.defModId = modid THEN Files.WriteString(R, "^") ELSE Files.WriteString(R, fld.defModId) END; Files.WriteInt(R, fld.defEndPos);
+            OutType(R, modid, fld.type); Files.WriteNum(R, fld.val)  (*offset*)
           ELSE (*hidden*) FindHiddenFields(R, fld.type, fld.val)
           END ;
           fld := fld.next
         END ;
         Write(R, 0)
-      ELSIF t.form IN {Proc, TProc} THEN OutType(R, t.base); OutPar(R, t.dsc, t.nofpar); Write(R, 0)
+      ELSIF t.form IN {Proc, TProc} THEN OutType(R, modid, t.base); OutPar(R, modid, t.dsc, t.nofpar); Write(R, 0)
       END ;
       IF (t.mno > 0) & (obj # NIL) THEN  (*re-export, output name*)
         mod := topScope.next;
@@ -382,13 +407,13 @@
       END
     END
   END OutType;
 
   PROCEDURE Export*(VAR modid: ORS.Ident; VAR newSF: BOOLEAN; VAR key: LONGINT);
     VAR x, sum, oldkey: LONGINT;
       obj, obj0: Object;
       filename: ORS.Ident;
       F, F1: Files.File; R, R1: Files.Rider;
-  BEGIN Ref := TProc + 1; MakeFileName(filename, modid, ".smb");
+  BEGIN Ref := TProc + 1; MakeFileName(filename, modid, ".smL");
     F := Files.New(filename); Files.Set(R, F, 0);
     Files.WriteInt(R, 0); (*placeholder*)
     Files.WriteInt(R, 0); (*placeholder for key to be inserted at the end*)
@@ -397,7 +422,8 @@
     WHILE obj # NIL DO
       IF obj.expo THEN
         Write(R, obj.class); Files.WriteString(R, obj.name);
-        OutType(R, obj.type);
+        Write(R, obj.lspClass); IF obj.defModId = modid THEN Files.WriteString(R, "^") ELSE Files.WriteString(R, obj.defModId) END; Files.WriteInt(R, obj.defEndPos);
+        OutType(R, modid, obj.type);
         IF obj.class = Typ THEN
           IF obj.type.form = Record THEN
             obj0 := topScope.next;  (*check whether this is base of previously declared pointer types*)
@@ -446,7 +472,8 @@
   PROCEDURE enter(name: ARRAY OF CHAR; cl: INTEGER; type: Type; n: LONGINT);
     VAR obj: Object;
   BEGIN NEW(obj); obj.name := name; obj.class := cl; obj.type := type; obj.val := n; obj.dsc := NIL;
-    IF cl = Typ THEN type.typobj := obj END ;
+    obj.lspClass := LSPhConstants.SynProcedure; obj.defEndPos := -1;
+    IF cl = Typ THEN obj.lspClass := LSPhConstants.SynType; type.typobj := obj END ;
     obj.next := system; system := obj
   END enter;
   
@@ -509,5 +536,5 @@
   enter("LDPSR", SProc, noType, 131);
   enter("COPY", SProc, noType, 123);
   enter("PUT", SProc, noType, 112);
-  enter("GET", SProc, noType, 102)
-END ORB.
+  enter("GET", SProc, noType, 102);
+END LSPhORB.
--- LSPhORG.Mod.txt
+++ LSPhORG.Mod.txt
@@ -1,5 +1,5 @@
-MODULE ORG; (* N.Wirth, 16.4.2016 / 4.4.2017 / 31.5.2019  Oberon compiler; code generator for RISC / AP 11.1.22 Extended Oberon*)
-  IMPORT SYSTEM, Files, ORS, ORB;
+MODULE LSPhORG; (* N.Wirth, 16.4.2016 / 4.4.2017 / 31.5.2019  Oberon compiler; code generator for RISC / AP 11.1.22 Extended Oberon*)
+  IMPORT SYSTEM, Files, ORS := LSPhORS, ORB := LSPhORB;
   (*Code generator for Oberon compiler for RISC processor.
      Procedural interface to Parser ORP; result in array "code".
      Procedure Close writes code-files*)
@@ -51,7 +51,6 @@
     version: INTEGER;  (* 0 = RISC-0, 1 = RISC-5 *)
 
     relmap: ARRAY 6 OF INTEGER;  (*condition codes for relations*)
-    code: ARRAY maxCode OF LONGINT;
     str: ARRAY maxStrx OF CHAR;  (*strings*)
     td: ARRAY maxTD OF LONGINT;  (*type descriptors*)
 
@@ -64,13 +63,12 @@
 
   PROCEDURE Put0(op, a, b, c: LONGINT);
   BEGIN (*emit format-0 register instruction*)
-    code[pc] := ((a*C4 + b) * C4 + op) * C16 + c; INC(pc)
+    INC(pc)
   END Put0;
 
   PROCEDURE Put1(op, a, b, im: LONGINT);
   BEGIN (*emit format-1 register instruction, -C16 <= im < C16*)
-    IF im < 0 THEN INC(op, V) END ;
-    code[pc] := (((a+C6) * C4 + b) * C4 + op) * C16 + im MOD C16; INC(pc)
+    INC(pc)
   END Put1;
 
   PROCEDURE Put1a(op, a, b, im: LONGINT);
@@ -91,22 +89,22 @@
 
   PROCEDURE Put1b(r, mno, off, disp: LONGINT);
   BEGIN (*emit modified register instruction to be fixed up by loader, 0 <= mno < 64, 0 <= off < 256*)
-    code[pc] := (((r+16) * C6 + mno) * C8 + off) * C12 + disp MOD C12; INC(pc)
+    INC(pc)
   END Put1b;
 
   PROCEDURE Put2(op, a, b, off: LONGINT);
   BEGIN (*emit load/store instruction*)
-    code[pc] := ((op * C4 + a) * C4 + b) * C20 + off MOD C20; INC(pc)
+    INC(pc)
   END Put2;
 
   PROCEDURE Put3(op, cond, off: LONGINT);
   BEGIN (*emit branch instruction*)
-    code[pc] := ((op+12) * C4 + cond) * C24 + off MOD C24; INC(pc)
+    INC(pc)
   END Put3;
 
   PROCEDURE Put3a(op, mno, pno, disp: LONGINT);
   BEGIN (*emit modified branch instruction to be fixed up by loader, 0 <= mno < 64*)
-    code[pc] := (((op+12) * C6 + mno) * C8 + pno) * C14 + disp MOD C14; INC(pc)
+    INC(pc)
   END Put3a;
 
   PROCEDURE PutPair(base, op, a, b, off, format: LONGINT);
@@ -151,19 +149,15 @@
   PROCEDURE fix1(at, with: LONGINT);
     VAR v: LONGINT;
   BEGIN (*fix format-1 register instruction*)
-    IF with < 0 THEN v := C28 (*set v bit*) ELSE v := 0 END ;
-    code[at] := code[at] DIV C16 * C16 + with MOD C16 + v
   END fix1;
 
   PROCEDURE fix3(at, with: LONGINT);
   BEGIN (*fix branch instruction*)
-    code[at] := code[at] DIV C24 * C24 + with MOD C24
   END fix3;
 
   PROCEDURE FixLinkWith(L, dst: LONGINT);
     VAR L1: LONGINT;
   BEGIN (*fix chain of branch instructions*)
-    WHILE L # 0 DO L1 := code[L] MOD C24; fix3(L, dst-L-1); L := L1 END
   END FixLinkWith;
 
   PROCEDURE FixLink*(L: LONGINT);
@@ -173,31 +167,16 @@
   PROCEDURE FixLinkMixed*(L: LONGINT);
     VAR L1, format: LONGINT; p: INTEGER;
   BEGIN (*fix chain of instructions of different formats*)
-    WHILE L # 0 DO p := code[L];
-      format := p DIV C30 MOD 4; L1 := p MOD C16;
-      IF format < 3 THEN fix1(L, (pc-L)*4) ELSE fix3(L, pc-L-1) END ;
-      L := L1
-    END
   END FixLinkMixed;
 
   PROCEDURE FixLinkPair(L, adr: LONGINT);
     VAR L1: LONGINT; p, q: INTEGER;
   BEGIN (*fix chain of instruction pairs with an address that is spread across both instructions, 0 <= adr < C24*)
-    WHILE L # 0 DO p := code[L-1]; q := code[L];
-      L1 := p DIV C12 MOD C8 + q MOD C16;
-      code[L-1] := p DIV C20 * C20 + adr DIV C16 MOD C8 * C12 + p MOD C12;
-      code[L] := q DIV C16 * C16 + adr MOD C16;
-      L := L1
-    END
   END FixLinkPair;
 
   PROCEDURE merged(L0, L1: LONGINT): LONGINT;
     VAR L2, L3: LONGINT;
   BEGIN (*merge chains of the two operands of AND and OR*)
-    IF L0 # 0 THEN L3 := L0;
-      REPEAT L2 := L3; L3 := code[L2] MOD C16 UNTIL L3 = 0;
-      code[L2] := code[L2] + L1; L1 := L0
-    END ;
     RETURN L1
   END merged;
 
@@ -253,7 +232,6 @@
       IF x.type.form = ORB.Bool THEN
         IF x.mode = ORB.Const THEN x.r := 15 - x.a*8
         ELSE load(x);
-          IF code[pc-1] DIV C30 # F2 THEN Put1(Cmp, x.r, x.r, 0) END ;
           x.r := NE; DEC(RH)
         END ;
         x.mode := Cond; x.a := 0; x.b := 0
@@ -640,7 +618,6 @@
   BEGIN
     IF (y.mode = ORB.Const) & (y.type.form # ORB.Proc) THEN
       load(x);
-      IF (y.a # 0) OR ~(op IN {ORS.eql, ORS.neq}) OR (code[pc-1] DIV C30 # F2) THEN Put1a(Cmp, x.r, x.r, y.a) END ;
       DEC(RH)
     ELSE
       IF (x.mode = Cond) OR (y.mode = Cond) THEN ORS.Mark("not implemented") END ;
@@ -1131,7 +1108,6 @@
   BEGIN pc := 0; final := -1; strx := 0; tdw := 0; RH := 0; check := v # 0; version := v;
     fixorgP := 0; fixorgD := 0; fixorgT := 0; fixorgM := 0;
     IF v = 0 THEN pc := 1;
-      REPEAT code[pc] := 0; INC(pc) UNTIL pc = 8
     END
   END Open;
 
@@ -1141,9 +1117,6 @@
 
   PROCEDURE Header*;
   BEGIN entry := pc*4;
-    IF version = 0 THEN code[0] := BCT - 1 + pc;  Put1a(Mov, SP, 0, StkOrg0)  (*RISC-0*)
-    ELSE Put1(Sub, SP, SP, 4); Put2(Str, LNK, SP, 0)
-    END
   END Header;
 
   PROCEDURE Exit*;
@@ -1186,7 +1159,9 @@
       i, comsize, nofimps, nofrefs, size, tdx, base: LONGINT;
       name: ORS.Ident;
       F: Files.File; R: Files.Rider;
-  BEGIN obj := ORB.topScope.next; nofimps := 0; comsize := 4; nofrefs := 0; tdx := varx + strx;
+  BEGIN
+    (* Disable writing of output file
+    obj := ORB.topScope.next; nofimps := 0; comsize := 4; nofrefs := 0; tdx := varx + strx;
     WHILE obj # NIL DO
       IF (obj.class = ORB.Mod) & (obj.dsc # ORB.system) THEN INC(nofimps)  (*count imports*)
       ELSIF (obj.exno # 0) & (obj.class = ORB.Const) & (obj.type.form = ORB.Proc)
@@ -1261,7 +1236,8 @@
     Files.WriteInt(R, fixorgP); Files.WriteInt(R, fixorgD); Files.WriteInt(R, fixorgT); Files.WriteInt(R, fixorgM);
     Files.WriteInt(R, entry); Files.WriteInt(R, final);
     Files.Write(R, "O"); Files.Register(F)
+    *)
   END Close;
 
 BEGIN relmap[0] := 1; relmap[1] := 9; relmap[2] := 5; relmap[3] := 6; relmap[4] := 14; relmap[5] := 13
-END ORG.
+END LSPhORG.
--- LSPhORP.Mod.txt
+++ LSPhORP.Mod.txt
@@ -1,5 +1,5 @@
-MODULE ORP; (*N. Wirth 1.7.97 / 8.3.2020  Oberon compiler for RISC in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
-  IMPORT Texts, Oberon, ORS, ORB, ORG;
+MODULE LSPhORP; (*N. Wirth 1.7.97 / 8.3.2020  Oberon compiler for RISC in Oberon-07 / AP 11.1.22 Extended Oberon with retro elements*)
+  IMPORT Texts, Oberon, RS232, LSPhConstants, ORS := LSPhORS, ORB := LSPhORB, ORG := LSPhORG;
   (*Author: Niklaus Wirth, 2014. Oberon-2 extensions by Andreas Pirklbauer, 2020.
     Parser of Oberon-RISC compiler. Uses Scanner ORS to obtain symbols (tokens),
     ORB for definition of data structures and for handling import and export, and
@@ -10,21 +10,20 @@
 
   TYPE PtrBase = POINTER TO PtrBaseDesc;
     PtrBaseDesc = RECORD  (*list of names of pointer base types*)
-      name: ORS.Ident; type: ORB.Type; next: PtrBase
+      name: ORS.Ident; type: ORB.Type; symPos: INTEGER; next: PtrBase;
     END ;
   
   VAR sym: INTEGER;   (*last symbol read*)
     dc, fc: LONGINT;    (*data counter, forward counter*)
     level, exno, version, looplev, exitno: INTEGER;
     newSF, retro, return: BOOLEAN;  (*option, retro and return flags*)
-    expression: PROCEDURE (VAR x: ORG.Item);  (*to avoid forward reference*)
+    expression1: PROCEDURE (VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);  (*to avoid forward reference*)
     Type: PROCEDURE (VAR type: ORB.Type; expo: BOOLEAN);
     FormalType: PROCEDURE (VAR typ: ORB.Type; dim: INTEGER);
     modid: ORS.Ident;
     pbsList: PtrBase;   (*list of names of pointer base types*)
     dummy: ORB.Object;
     exit: ARRAY maxExit OF INTEGER;
-    W: Texts.Writer;
 
   PROCEDURE Check(s: INTEGER; msg: ARRAY OF CHAR);
   BEGIN
@@ -91,7 +90,9 @@
   PROCEDURE CheckExport(VAR expo: BOOLEAN);
   BEGIN
     IF (sym = ORS.times) OR (sym = ORS.minus) THEN
-      expo := TRUE; ORS.Get(sym);
+     ORS.FormatTokenUpdate(01);
+     ORS.ModuleTagH(LSPhConstants.NameExported);
+     expo := TRUE; ORS.Get(sym);
       IF level # 0 THEN ORS.Mark("remove export mark") END ;
       IF sym = ORS.minus THEN CheckRetro END
     ELSE expo := FALSE
@@ -138,11 +139,17 @@
     IF ~guard THEN x.type := ORB.boolType END
   END TypeTest;
 
-  PROCEDURE selector(VAR x: ORG.Item);
+  PROCEDURE expression(VAR x: ORG.Item);
+  VAR dummy: BOOLEAN;
+  BEGIN expression1(x, dummy)
+  END expression;
+
+  PROCEDURE selector(VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);
     VAR y: ORG.Item; obj, fld: ORB.Object; xt: ORB.Type;
-  BEGIN
+  BEGIN symAtEnd := TRUE;
     WHILE (sym = ORS.lbrak) OR (sym = ORS.period) OR (sym = ORS.arrow)
         OR (sym = ORS.lparen) & (x.type.form IN {ORB.Record, ORB.Pointer}) DO x.obj := NIL;
+      symAtEnd := FALSE;
       IF sym = ORS.lbrak THEN
         IF x.type.form = ORB.Pointer THEN ORG.DeRef(x); x.type := x.type.base END ;
         REPEAT ORS.Get(sym); expression(y);
@@ -155,6 +162,7 @@
       ELSIF sym = ORS.period THEN
         ORS.Get(sym);
         IF sym = ORS.ident THEN
+          symAtEnd := TRUE;
           IF x.type.form = ORB.Pointer THEN ORG.DeRef(x); x.type := x.type.base END ;
           IF x.type.form = ORB.Record THEN
             obj := ORB.thisfield(x.type); ORS.Get(sym);
@@ -239,14 +247,15 @@
   END CompTypes;
 
   PROCEDURE Parameter(par: ORB.Object);
-    VAR x: ORG.Item; varpar: BOOLEAN;
-  BEGIN expression(x);
+    VAR x: ORG.Item; varpar, symAtEnd: BOOLEAN;
+  BEGIN expression1(x, symAtEnd);
     IF par # NIL THEN
       varpar := par.class = ORB.Par;
       IF CompTypes(par.type, x.type, varpar) THEN
         IF ~varpar THEN ORG.ValueParam(x)
         ELSE (*par.class = Par*)
           IF ~par.rdo THEN CheckReadOnly(x) END ;
+          IF symAtEnd THEN ORS.ModuleTagH(LSPhConstants.VarModified) END;
           ORG.VarParam(x, par.type)
         END
       ELSIF (x.type.form = ORB.Array) & (par.type.form = ORB.Array) &
@@ -276,12 +285,12 @@
     IF sym # ORS.rparen THEN
       Parameter(par); INC(n);
       WHILE sym <= ORS.comma DO
-        Check(ORS.comma, "comma?");
+        ORS.ModuleTagP(LSPhConstants.ParamNext); Check(ORS.comma, "comma?");
         IF par # NIL THEN par := par.next END ;
         Parameter(par); INC(n)
       END ;
-      Check(ORS.rparen, ") missing")
-    ELSE ORS.Get(sym);
+      ORS.ModuleTagP(LSPhConstants.ParamEnd); Check(ORS.rparen, ") missing")
+    ELSE ORS.ModuleTagP(LSPhConstants.ParamEnd); ORS.Get(sym);
     END ;
     IF n < x.type.nofpar THEN ORS.Mark("too few params")
     ELSIF n > x.type.nofpar THEN ORS.Mark("too many params")
@@ -289,10 +298,12 @@
   END ParamList;
 
   PROCEDURE StandFunc(VAR x: ORG.Item; fct: LONGINT; restyp: ORB.Type);
-    VAR y: ORG.Item; n, npar: LONGINT;
-  BEGIN Check(ORS.lparen, "no (");
+    VAR y: ORG.Item; n, npar: LONGINT; symAtEnd: BOOLEAN;
+  BEGIN
+    ORS.ModuleTagP(LSPhConstants.CallParamStart); ORS.FormatTokenUpdate(00);
+    Check(ORS.lparen, "no (");
     npar := fct MOD 10; fct := fct DIV 10; expression(x); n := 1;
-    WHILE sym = ORS.comma DO ORS.Get(sym); expression(y); INC(n) END ;
+    WHILE sym = ORS.comma DO ORS.ModuleTagP(LSPhConstants.ParamNext); ORS.Get(sym); expression(y); INC(n) END ;
     Check(ORS.rparen, "no )");
     IF n = npar THEN
       IF fct = 0 THEN (*ABS*)
@@ -355,22 +366,23 @@
     END
   END set; 
 
-  PROCEDURE factor(VAR x: ORG.Item);
+  PROCEDURE factor(VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);
     VAR obj: ORB.Object; rx: LONGINT;
   BEGIN (*sync*)
     IF (sym < ORS.char) OR (sym > ORS.ident) THEN ORS.Mark("expression expected");
       REPEAT ORS.Get(sym) UNTIL (sym >= ORS.char) & (sym <= ORS.for) OR (sym >= ORS.then)
     END ;
+    symAtEnd := FALSE;
     IF sym = ORS.ident THEN
-      qualident(obj);
-      IF obj.class = ORB.SFunc THEN StandFunc(x, obj.val, obj.type)
-      ELSE ORG.MakeItem(x, obj); selector(x);
+      qualident(obj); symAtEnd := TRUE;
+      IF obj.class = ORB.SFunc THEN StandFunc(x, obj.val, obj.type); symAtEnd := FALSE
+      ELSE ORG.MakeItem(x, obj); selector(x, symAtEnd);
         IF sym = ORS.lparen THEN
-          ORS.Get(sym);
+          ORS.FormatTokenUpdate(00); ORS.ModuleTagP(LSPhConstants.CallParamStart); ORS.Get(sym);
           IF (x.type.form IN {ORB.Proc, ORB.TProc}) & (x.type.base.form # ORB.NoTyp) THEN
             ORG.PrepCall(x, rx); ParamList(x); ORG.Call(x, rx); x.type := x.type.base
           ELSE ORS.Mark("not a function"); ParamList(x)
-          END
+          END; symAtEnd := FALSE
         END
       END
     ELSIF sym = ORS.int THEN ORG.MakeConstItem(x, ORB.intType, ORS.ival); ORS.Get(sym)
@@ -378,61 +390,61 @@
     ELSIF sym = ORS.char THEN ORG.MakeConstItem(x, ORB.charType, ORS.ival); ORS.Get(sym)
     ELSIF sym = ORS.nil THEN ORS.Get(sym); ORG.MakeConstItem(x, ORB.nilType, 0)
     ELSIF sym = ORS.string THEN ORG.MakeStringItem(x, ORS.slen); ORS.Get(sym)
-    ELSIF sym = ORS.lparen THEN ORS.Get(sym); expression(x); Check(ORS.rparen, "no )")
+    ELSIF sym = ORS.lparen THEN ORS.Get(sym); expression1(x, symAtEnd); Check(ORS.rparen, "no )"); symAtEnd := FALSE
     ELSIF sym = ORS.lbrace THEN ORS.Get(sym); set(x); Check(ORS.rbrace, "no }")
-    ELSIF sym = ORS.not THEN ORS.Get(sym); factor(x); CheckBool(x); ORG.Not(x)
+    ELSIF sym = ORS.not THEN ORS.Get(sym); factor(x, symAtEnd); CheckBool(x); ORG.Not(x)
     ELSIF sym = ORS.false THEN ORS.Get(sym); ORG.MakeConstItem(x, ORB.boolType, 0)
     ELSIF sym = ORS.true THEN ORS.Get(sym); ORG.MakeConstItem(x, ORB.boolType, 1)
     ELSE ORS.Mark("not a factor"); ORG.MakeConstItem(x, ORB.intType, 0)
     END
   END factor;
 
-  PROCEDURE term(VAR x: ORG.Item);
+  PROCEDURE term(VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);
     VAR y: ORG.Item; op, f: INTEGER;
-  BEGIN factor(x); f := x.type.form;
+  BEGIN factor(x, symAtEnd); f := x.type.form;
     WHILE (sym >= ORS.times) & (sym <= ORS.and) DO
       op := sym; ORS.Get(sym);
       IF op = ORS.times THEN
-        IF f = ORB.Int THEN factor(y); CheckInt(y); ORG.MulOp(x, y)
-        ELSIF f = ORB.Real THEN factor(y); CheckReal(y); ORG.RealOp(op, x, y)
-        ELSIF f = ORB.Set THEN factor(y); CheckSet(y); ORG.SetOp(op, x, y)
+        IF f = ORB.Int THEN factor(y, symAtEnd); CheckInt(y); ORG.MulOp(x, y)
+        ELSIF f = ORB.Real THEN factor(y, symAtEnd); CheckReal(y); ORG.RealOp(op, x, y)
+        ELSIF f = ORB.Set THEN factor(y, symAtEnd); CheckSet(y); ORG.SetOp(op, x, y)
         ELSE ORS.Mark("bad type")
         END
       ELSIF (op = ORS.div) OR (op = ORS.mod) THEN
-        CheckInt(x); factor(y); CheckInt(y); ORG.DivOp(op, x, y)
+        CheckInt(x); factor(y, symAtEnd); CheckInt(y); ORG.DivOp(op, x, y)
       ELSIF op = ORS.rdiv THEN
-        IF f = ORB.Real THEN factor(y); CheckReal(y); ORG.RealOp(op, x, y)
-        ELSIF f = ORB.Set THEN factor(y); CheckSet(y); ORG.SetOp(op, x, y)
+        IF f = ORB.Real THEN factor(y, symAtEnd); CheckReal(y); ORG.RealOp(op, x, y)
+        ELSIF f = ORB.Set THEN factor(y, symAtEnd); CheckSet(y); ORG.SetOp(op, x, y)
         ELSE ORS.Mark("bad type")
         END
-      ELSE (*op = and*) CheckBool(x); ORG.And1(x); factor(y); CheckBool(y); ORG.And2(x, y)
+      ELSE (*op = and*) CheckBool(x); ORG.And1(x); factor(y, symAtEnd); CheckBool(y); ORG.And2(x, y)
       END
     END
   END term;
 
-  PROCEDURE SimpleExpression(VAR x: ORG.Item);
+  PROCEDURE SimpleExpression(VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);
     VAR y: ORG.Item; op: INTEGER;
   BEGIN
-    IF sym = ORS.minus THEN ORS.Get(sym); term(x);
+    IF sym = ORS.minus THEN ORS.FormatTokenUpdate(90); ORS.Get(sym); term(x, symAtEnd);
       IF x.type.form IN {ORB.Int, ORB.Real, ORB.Set} THEN ORG.Neg(x) ELSE CheckInt(x) END
-    ELSIF sym = ORS.plus THEN ORS.Get(sym); term(x);
-    ELSE term(x)
+    ELSIF sym = ORS.plus THEN ORS.FormatTokenUpdate(90); ORS.Get(sym); term(x, symAtEnd);
+    ELSE term(x, symAtEnd)
     END ;
     WHILE (sym >= ORS.plus) & (sym <= ORS.or) DO
       op := sym; ORS.Get(sym);
-      IF op = ORS.or THEN ORG.Or1(x); CheckBool(x); term(y); CheckBool(y); ORG.Or2(x, y)
-      ELSIF x.type.form = ORB.Int THEN term(y); CheckInt(y); ORG.AddOp(op, x, y)
-      ELSIF x.type.form = ORB.Real THEN term(y); CheckReal(y); ORG.RealOp(op, x, y)
-      ELSE CheckSet(x); term(y); CheckSet(y); ORG.SetOp(op, x, y)
+      IF op = ORS.or THEN ORG.Or1(x); CheckBool(x); term(y, symAtEnd); CheckBool(y); ORG.Or2(x, y)
+      ELSIF x.type.form = ORB.Int THEN term(y, symAtEnd); CheckInt(y); ORG.AddOp(op, x, y)
+      ELSIF x.type.form = ORB.Real THEN term(y, symAtEnd); CheckReal(y); ORG.RealOp(op, x, y)
+      ELSE CheckSet(x); term(y, symAtEnd); CheckSet(y); ORG.SetOp(op, x, y)
       END
     END
   END SimpleExpression;
 
-  PROCEDURE expression0(VAR x: ORG.Item);
+  PROCEDURE expression0(VAR x: ORG.Item; VAR symAtEnd: BOOLEAN);
     VAR y: ORG.Item; obj: ORB.Object; rel, xf, yf: INTEGER;
-  BEGIN SimpleExpression(x);
+  BEGIN SimpleExpression(x, symAtEnd);
     IF (sym >= ORS.eql) & (sym <= ORS.geq) THEN
-      rel := sym; ORS.Get(sym); SimpleExpression(y); xf := x.type.form; yf := y.type.form;
+      rel := sym; ORS.Get(sym); SimpleExpression(y, symAtEnd); xf := x.type.form; yf := y.type.form;
       IF x.type = y.type THEN
         IF (xf IN {ORB.Char, ORB.Int}) THEN ORG.IntRelation(rel, x, y)
         ELSIF xf = ORB.Real THEN ORG.RealRelation(rel, x, y)
@@ -462,10 +474,10 @@
       END ;
       x.type := ORB.boolType
     ELSIF sym = ORS.in THEN
-      ORS.Get(sym); CheckInt(x); SimpleExpression(y); CheckSet(y); ORG.In(x, y) ;
+      ORS.Get(sym); CheckInt(x); SimpleExpression(y, symAtEnd); CheckSet(y); ORG.In(x, y) ;
       x.type := ORB.boolType
     ELSIF sym = ORS.is THEN
-      ORS.Get(sym); qualident(obj); TypeTest(x, obj.type, FALSE) ;
+      ORS.Get(sym); qualident(obj); TypeTest(x, obj.type, FALSE); symAtEnd := TRUE;
       x.type := ORB.boolType
     END
   END expression0;
@@ -474,15 +486,16 @@
 
   PROCEDURE StandProc(pno: LONGINT);
     VAR nap, npar: LONGINT; (*nof actual/formal parameters*)
-      x, y, z: ORG.Item;
-  BEGIN Check(ORS.lparen, "no (");
-    npar := pno MOD 10; pno := pno DIV 10; expression(x); nap := 1;
+      x, y, z: ORG.Item; symAtEnd: BOOLEAN;
+  BEGIN ORS.FormatTokenUpdate(00); ORS.ModuleTagP(LSPhConstants.CallParamStart); Check(ORS.lparen, "no (");
+    npar := pno MOD 10; pno := pno DIV 10; expression1(x, symAtEnd); nap := 1;
+    IF symAtEnd & (pno IN {0,1,2,3,5,6,7}) THEN ORS.ModuleTagH(LSPhConstants.VarModified) END;
     IF sym = ORS.comma THEN
-      ORS.Get(sym); expression(y); nap := 2; z.type := ORB.noType;
-      WHILE sym = ORS.comma DO ORS.Get(sym); expression(z); INC(nap) END
+      ORS.ModuleTagP(LSPhConstants.ParamNext); ORS.Get(sym); expression(y); nap := 2; z.type := ORB.noType;
+      WHILE sym = ORS.comma DO ORS.ModuleTagP(LSPhConstants.ParamNext); ORS.Get(sym); expression(z); INC(nap) END
     ELSE y.type := ORB.noType
     END ;
-    Check(ORS.rparen, "no )");
+    ORS.ModuleTagP(LSPhConstants.ParamEnd); Check(ORS.rparen, "no )");
     IF (npar = nap) OR (pno IN {0, 1, 5}) THEN
       IF pno IN {0, 1} THEN (*INC, DEC*)
         CheckInt(x); CheckReadOnly(x);
@@ -521,6 +534,7 @@
 
   PROCEDURE StatSequence;
     VAR obj: ORB.Object;
+      symAtEnd: BOOLEAN;
       x, y, z, w: ORG.Item;
       L0, L1, rx: LONGINT;
 
@@ -540,7 +554,9 @@
 
     PROCEDURE TypeCasePart(obj: ORB.Object);
       VAR L0: LONGINT;
-    BEGIN Check(ORS.of, "OF expected"); L0 := 0;
+    BEGIN
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      Check(ORS.of, "OF expected"); L0 := 0;
       WHILE sym <= ORS.bar DO
         IF sym = ORS.bar THEN ORS.Get(sym) ELSE TypeCase(obj, L0) END
       END ;
@@ -607,7 +623,9 @@
     PROCEDURE NumericCasePart(VAR x: ORG.Item);
       VAR L0, L1, L2: LONGINT; n, labelform: INTEGER;
         tab: ARRAY NofCases OF ORG.LabelRange;  (*ordered table of label ranges*)
-    BEGIN Check(ORS.of, "OF expected"); ORG.CaseHead(x, L0); n := 0; L2 := 0; labelform := x.type.form;
+    BEGIN
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      Check(ORS.of, "OF expected"); ORG.CaseHead(x, L0); n := 0; L2 := 0; labelform := x.type.form;
       WHILE sym <= ORS.bar DO
         IF sym = ORS.bar THEN ORS.Get(sym) ELSE NumericCase(labelform, n, tab); ORG.FJump(L2) END
       END ;
@@ -637,8 +655,9 @@
       IF sym = ORS.ident THEN
         qualident(obj); ORG.MakeItem(x, obj);
         IF x.mode = ORB.SProc THEN StandProc(obj.val)
-        ELSE selector(x);
+        ELSE selector(x, symAtEnd);
           IF sym = ORS.becomes THEN (*assignment*)
+            IF symAtEnd THEN ORS.ModuleTagH(LSPhConstants.VarModified) END;
             ORS.Get(sym); CheckReadOnly(x); expression(y);
             IF CompTypes(x.type, y.type, FALSE) THEN
               IF (x.type.form <= ORB.Pointer) OR (x.type.form = ORB.Proc) THEN ORG.Store(x, y)
@@ -655,7 +674,7 @@
             END
           ELSIF sym = ORS.eql THEN ORS.Mark("should be :="); ORS.Get(sym); expression(y)
           ELSIF sym = ORS.lparen THEN (*procedure call*)
-            ORS.Get(sym);
+            ORS.FormatTokenUpdate(00); ORS.ModuleTagP(LSPhConstants.CallParamStart); ORS.Get(sym);
             IF (x.type.form IN {ORB.Proc, ORB.TProc}) & (x.type.base.form = ORB.NoTyp) THEN
               ORG.PrepCall(x, rx); ParamList(x); ORG.Call(x, rx)
             ELSE ORS.Mark("not a procedure"); ParamList(x)
@@ -669,27 +688,39 @@
         END
       ELSIF sym = ORS.if THEN
         ORS.Get(sym); expression(x); CheckBool(x); ORG.CFJump(x);
+        ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
         Check(ORS.then, "no THEN");
         StatSequence; L0 := 0;
         WHILE sym = ORS.elsif DO
+          ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
           ORS.Get(sym); ORG.FJump(L0); ORG.Fixup(x); expression(x); CheckBool(x);
+          ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
           ORG.CFJump(x); Check(ORS.then, "no THEN"); StatSequence
         END ;
-        IF sym = ORS.else THEN ORS.Get(sym); ORG.FJump(L0); ORG.Fixup(x); StatSequence
+        IF sym = ORS.else THEN
+          ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
+          ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+          ORS.Get(sym); ORG.FJump(L0); ORG.Fixup(x); StatSequence
         ELSE ORG.Fixup(x)
         END ;
+        ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
         ORG.FixLink(L0); Check(ORS.end, "no END")
       ELSIF sym = ORS.while THEN
         ORS.Get(sym); L0 := ORG.Here(); expression(x); CheckBool(x); ORG.CFJump(x);
+        ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
         Check(ORS.do, "no DO"); StatSequence; ORG.BJump(L0);
         WHILE sym = ORS.elsif DO
           ORS.Get(sym); ORG.Fixup(x); expression(x); CheckBool(x); ORG.CFJump(x);
+          ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
           Check(ORS.do, "no DO"); StatSequence; ORG.BJump(L0)
         END ;
+        ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
         ORG.Fixup(x); Check(ORS.end, "no END")
       ELSIF sym = ORS.repeat THEN
+        ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
         ORS.Get(sym); L0 := ORG.Here(); StatSequence;
         IF sym = ORS.until THEN
+          ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
           ORS.Get(sym); expression(x); CheckBool(x); ORG.CBJump(x, L0)
         ELSE ORS.Mark("missing UNTIL")
         END
@@ -720,13 +751,17 @@
         IF sym = ORS.ident THEN
           qualident(obj); ORG.MakeItem(x, obj); CheckInt(x); CheckReadOnly(x);
           IF sym = ORS.becomes THEN
+            ORS.ModuleTagH(LSPhConstants.VarModified);
             ORS.Get(sym); expression(y); CheckInt(y); ORG.For0(x, y); L0 := ORG.Here();
             Check(ORS.to, "no TO"); expression(z); CheckInt(z); obj.rdo := TRUE;
             IF sym = ORS.by THEN ORS.Get(sym); expression(w); CheckConst(w); CheckInt(w)
             ELSE ORG.MakeConstItem(w, ORB.intType, 1)
             END ;
+            ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
             Check(ORS.do, "no DO"); ORG.For1(x, y, z, w, L1);
-            StatSequence; Check(ORS.end, "no END");
+            StatSequence;
+            ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
+            Check(ORS.end, "no END");
             ORG.For2(x, y, w); ORG.BJump(L0); ORG.FixLink(L1); obj.rdo := FALSE
           ELSE ORS.Mark(":= expected")
           END
@@ -738,8 +773,9 @@
         ELSIF (x.obj # NIL) & (x.obj.type # NIL) &
           ((x.type.form = ORB.Pointer) & (x.type.base.form = ORB.Record) OR
           (x.type.form = ORB.Record) & (x.mode = ORB.Par)) THEN TypeCasePart(x.obj)
-        ELSE ORS.Mark("invalid case variable"); SkipCase
+        ELSE ORS.FormatTokenTag(LSPhConstants.IndentNextLine); ORS.Mark("invalid case variable"); SkipCase
         END ;
+        ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
         Check(ORS.end, "no END")
       ELSIF sym = ORS.with THEN
         ORS.Get(sym); WithPart; Check(ORS.end, "no END")
@@ -753,19 +789,22 @@
 
   (* Types and declarations *)
 
-  PROCEDURE IdentList(class: INTEGER; VAR first: ORB.Object);
+  PROCEDURE IdentList(class, lspClass: INTEGER; VAR first: ORB.Object; procdecl, proctype: BOOLEAN);
     VAR obj: ORB.Object;
   BEGIN
     IF sym = ORS.ident THEN
-      ORB.NewObj(first, ORS.id, class); ORS.Get(sym); CheckExport(first.expo);
+      ORS.ClassifyIdent(lspClass, ORS.Pos(), modid);
+      IF proctype THEN ORS.ModuleTag(LSPhConstants.DefinitionUsed) END;
+      ORB.NewObj(first, ORS.id, modid, class, lspClass); ORS.Get(sym); CheckExport(first.expo);
       WHILE sym = ORS.comma DO
-        ORS.Get(sym);
-        IF sym = ORS.ident THEN ORB.NewObj(obj, ORS.id, class); ORS.Get(sym); CheckExport(obj.expo)
+        IF procdecl THEN ORS.ModuleTagP(LSPhConstants.ParamNext) END; ORS.Get(sym);
+        IF sym = ORS.ident THEN ORS.ClassifyIdent(lspClass, ORS.Pos(), modid); ORB.NewObj(obj, ORS.id, modid, class, lspClass); ORS.Get(sym); CheckExport(obj.expo)
         ELSE ORS.Mark("ident?")
         END
       END ;
+      ORS.ModuleTagP(LSPhConstants.DefinitionListValue);
       IF sym = ORS.colon THEN ORS.Get(sym) ELSE ORS.Mark(":?") END
-    ELSE first := NIL
+    ELSE ORS.ModuleTagP(LSPhConstants.DefinitionListValue); first := NIL
     END
   END IdentList;
 
@@ -789,7 +828,7 @@
     typ.form := ORB.Array; type := typ
   END ArrayType;
 
-  PROCEDURE RecordType(VAR type: ORB.Type; expo: BOOLEAN);
+  PROCEDURE RecordType(VAR type: ORB.Type; startPos: INTEGER; expo: BOOLEAN);
     VAR obj, obj0, new, bot, base: ORB.Object;
       typ, tp: ORB.Type;
       offset, off, n: LONGINT; expo0: BOOLEAN;
@@ -809,38 +848,51 @@
         END
       ELSE ORS.Mark("ident expected")
       END ;
+      startPos := ORS.Pos();
       Check(ORS.rparen, "no )")
     END ;
     WHILE sym = ORS.ident DO  (*fields*)
+      ORS.ModuleTagPP(LSPhConstants.DefinitionListStart, startPos);
       n := 0; obj := bot; expo0 := TRUE;
       WHILE sym = ORS.ident DO
         obj0 := obj;
         WHILE (obj0 # NIL) & (obj0.name # ORS.id) DO obj0 := obj0.next END ;
         IF obj0 # NIL THEN ORS.Mark("mult def") END ;
         NEW(new); ORS.CopyId(new.name); new.class := ORB.Fld; new.next := obj; obj := new; INC(n);
+        new.lspClass := LSPhConstants.SynRecordField; new.defEndPos := ORS.Pos(); new.defModId := modid;
+        ORS.ClassifyIdent(LSPhConstants.SynRecordField, ORS.Pos(), modid);
         ORS.Get(sym); CheckExport(new.expo);
         IF ~new.expo THEN expo0 := FALSE ELSIF ~expo THEN ORS.Mark("invalid field export") END ;
         IF (sym # ORS.comma) & (sym # ORS.colon) THEN ORS.Mark("comma expected")
         ELSIF sym = ORS.comma THEN ORS.Get(sym)
         END
       END ;
+      ORS.ModuleTagP(LSPhConstants.DefinitionListValue);
       Check(ORS.colon, "colon expected"); Type(tp, expo & expo0);
       IF (tp.form = ORB.Array) & (tp.len < 0) THEN ORS.Mark("dyn array not allowed") END ;
       IF tp.size > 1 THEN offset := (offset+3) DIV 4 * 4 END ;
       offset := offset + n * tp.size; off := offset; obj0 := obj;
       WHILE obj0 # bot DO obj0.type := tp; obj0.lev := 0; off := off - tp.size; obj0.val := off; obj0 := obj0.next END ;
       bot := obj;
-      IF sym = ORS.semicolon THEN ORS.Get(sym) ELSIF sym # ORS.end THEN ORS.Mark(" ; or END") END
+      startPos := ORS.Pos();
+      IF sym = ORS.semicolon THEN
+        ORS.ModuleTagP(LSPhConstants.DefinitionListEnd); ORS.Get(sym)
+      ELSIF sym = ORS.end THEN
+        ORS.ModuleTagPP(LSPhConstants.DefinitionListEnd, ORS.Pos() - 3)
+      ELSE
+        ORS.ModuleTagP(LSPhConstants.DefinitionListEnd); ORS.Mark(" ; or END")
+      END
     END ;
     typ.form := ORB.Record; typ.dsc := bot; typ.size := (offset + 3) DIV 4 * 4; type := typ
   END RecordType;
 
-  PROCEDURE FPSection(VAR adr: LONGINT; VAR nofpar: INTEGER);
+  PROCEDURE FPSection(VAR adr: LONGINT; VAR nofpar, paramStart: INTEGER; decl: BOOLEAN);
     VAR obj, first: ORB.Object; tp: ORB.Type;
       parsize: LONGINT; cl: INTEGER; rdo: BOOLEAN;
   BEGIN
+    ORS.ModuleTagPP(LSPhConstants.DefinitionListStart, paramStart);
     IF sym = ORS.var THEN ORS.Get(sym); cl := ORB.Par ELSE cl := ORB.Var END ;
-    IdentList(cl, first); FormalType(tp, 0); rdo := FALSE;
+    IdentList(cl, LSPhConstants.SynParameter, first, decl, ~decl); FormalType(tp, 0); rdo := FALSE;
     IF (cl = ORB.Var) & (tp.form >= ORB.Array) THEN cl := ORB.Par; rdo := TRUE END ;
     IF (tp.form = ORB.Array) & (tp.len < 0) OR (tp.form = ORB.Record) THEN
       parsize := 2*ORG.WordSize  (*open array or record, needs second word for length or type tag*)
@@ -851,18 +903,19 @@
       INC(nofpar); obj.class := cl; obj.type := tp; obj.rdo := rdo; obj.lev := level; obj.val := adr;
       adr := adr + parsize; obj := obj.next
     END ;
+    ORS.ModuleTagP(LSPhConstants.DefinitionListEnd);
     IF adr >= 52 THEN ORS.Mark("too many parameters") END
   END FPSection;
 
-  PROCEDURE ProcedureType(ptype: ORB.Type; VAR parblksize: LONGINT);
-    VAR obj: ORB.Object; size: LONGINT; nofpar: INTEGER;
+  PROCEDURE ProcedureType(ptype: ORB.Type; VAR parblksize: LONGINT; decl: BOOLEAN);
+    VAR obj: ORB.Object; size: LONGINT; nofpar, paramStart: INTEGER;
   BEGIN ptype.base := ORB.noType; size := parblksize; nofpar := 0; ptype.dsc := NIL;
     IF sym = ORS.lparen THEN
-      ORS.Get(sym);
-      IF sym = ORS.rparen THEN ORS.Get(sym)
-      ELSE FPSection(size, nofpar);
-        WHILE sym = ORS.semicolon DO ORS.Get(sym); FPSection(size, nofpar) END ;
-        Check(ORS.rparen, "no )")
+      IF decl THEN ORS.FormatTokenUpdate(00); ORS.ModuleTagP(LSPhConstants.ProcParamStart) END; paramStart := ORS.Pos(); ORS.Get(sym);
+      IF sym = ORS.rparen THEN IF decl THEN ORS.ModuleTagP(LSPhConstants.ParamEnd) END; ORS.Get(sym)
+      ELSE FPSection(size, nofpar, paramStart, decl);
+        WHILE sym = ORS.semicolon DO IF decl THEN ORS.ModuleTagP(LSPhConstants.ParamNext) END; paramStart := ORS.Pos(); ORS.Get(sym); FPSection(size, nofpar, paramStart, decl) END ;
+        IF decl THEN ORS.ModuleTagP(LSPhConstants.ParamEnd) END; Check(ORS.rparen, "no )")
       END ;
       IF sym = ORS.colon THEN  (*function*)
         ORS.Get(sym);
@@ -891,7 +944,7 @@
       FormalType(typ.base, dim+1)
     ELSIF sym = ORS.procedure THEN
       ORS.Get(sym); ORB.OpenScope;
-      NEW(typ); typ.form := ORB.Proc; typ.size := ORG.WordSize; dmy := 0; ProcedureType(typ, dmy);
+      NEW(typ); typ.form := ORB.Proc; typ.size := ORG.WordSize; dmy := 0; ProcedureType(typ, dmy, FALSE);
       typ.dsc := ORB.topScope.next; ORB.CloseScope
     ELSE ORS.Mark("identifier expected"); typ := ORB.noType
     END
@@ -916,7 +969,12 @@
       END
     ELSIF sym = ORS.array THEN ORS.Get(sym); ArrayType(type, expo)
     ELSIF sym = ORS.record THEN
-      ORS.Get(sym); RecordType(type, expo); Check(ORS.end, "no END")
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      ORS.ModuleTag(LSPhConstants.RecordStart);
+      dmy := ORS.Pos(); ORS.Get(sym); RecordType(type, dmy, expo);
+      ORS.ModuleTag(LSPhConstants.RecordEnd);
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
+      Check(ORS.end, "no END")
     ELSIF sym = ORS.pointer THEN
       ORS.Get(sym); Check(ORS.to, "no TO");
       NEW(type);  type.form := ORB.Pointer; type.size := ORG.WordSize; type.base := ORB.intType;
@@ -929,7 +987,8 @@
           ELSE ORS.Mark("no valid base type")
           END
         ELSE CheckRecLevel(level); (*enter into list of forward references to be fixed in Declarations*)
-          NEW(ptbase); ORS.CopyId(ptbase.name); ptbase.type := type; ptbase.next := pbsList; pbsList := ptbase
+          ORS.ModuleTagH(LSPhConstants.ForwardPointer);
+          NEW(ptbase); ORS.CopyId(ptbase.name); ptbase.type := type; ptbase.symPos := ORS.Pos(); ptbase.next := pbsList; pbsList := ptbase
         END ;
         ORS.Get(sym)
       ELSE Type(type.base, expo);
@@ -941,7 +1000,7 @@
     ELSIF sym = ORS.procedure THEN
       ORS.Get(sym); ORB.OpenScope;
       NEW(type); type.form := ORB.Proc; type.size := ORG.WordSize; dmy := 0;
-      ProcedureType(type, dmy); type.dsc := ORB.topScope.next; ORB.CloseScope
+      ProcedureType(type, dmy, FALSE); type.dsc := ORB.topScope.next; ORB.CloseScope
     ELSE ORS.Mark("illegal type")
     END
   END Type0;
@@ -950,49 +1009,85 @@
     VAR obj, first: ORB.Object;
       x: ORG.Item; tp: ORB.Type; ptbase: PtrBase;
       expo: BOOLEAN; id: ORS.Ident;
+      typePos, endPos: INTEGER;
   BEGIN (*sync*) pbsList := NIL;
     IF (sym < ORS.const) & (sym # ORS.end) THEN ORS.Mark("declaration?");
       REPEAT ORS.Get(sym) UNTIL (sym >= ORS.const) OR (sym = ORS.end)
     END ;
     IF sym = ORS.const THEN
+      ORS.ModuleTagPP(LSPhConstants.DeclarationBlockStart, ORS.Pos() - 5);
+      IF level = 0 THEN ORS.FormatTokenUpdate(31) END;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      endPos := ORS.Pos();
       ORS.Get(sym);
       WHILE sym = ORS.ident DO
-        ORS.CopyId(id); ORS.Get(sym); CheckExport(expo);
+        ORS.CopyId(id); ORS.ClassifyIdent(LSPhConstants.SynConstant, ORS.Pos(), modid);
+        ORS.ModuleTagPP(LSPhConstants.DefinitionListStart, endPos);
+        ORS.ModuleTagP(LSPhConstants.DefinitionListValue);
+        ORB.NewObj(obj, id, modid, ORB.Const, LSPhConstants.SynConstant); ORS.Get(sym); CheckExport(expo);
         IF sym = ORS.eql THEN ORS.Get(sym) ELSE ORS.Mark("= ?") END;
         expression(x);
         IF (x.type.form = ORB.String) & (x.b = 2) THEN ORG.StrToChar(x) END ;
-        ORB.NewObj(obj, id, ORB.Const); obj.expo := expo; obj.lev := level;
+        obj.expo := expo; obj.lev := level;
         IF x.mode = ORB.Const THEN obj.type := x.type;
           IF expo & (obj.type.form = ORB.String) THEN obj.exno := exno; INC(exno) ELSE obj.exno := 0 END ;
           IF obj.type.form = ORB.String THEN obj.val := x.a (*strx*) + x.b (*len*) * C20 ELSE obj.val := x.a END
         ELSE ORS.Mark("expression not constant"); obj.type := ORB.intType
         END;
+        endPos := ORS.Pos();
+        ORS.ModuleTagP(LSPhConstants.DefinitionListEnd);
         Check(ORS.semicolon, "; missing")
       END
+      ;ORS.ModuleTagPP(LSPhConstants.DeclarationBlockEnd, endPos);
     END ;
     IF sym = ORS.type THEN
+      ORS.ModuleTagPP(LSPhConstants.DeclarationBlockStart, ORS.Pos() - 4);
+      IF level = 0 THEN ORS.FormatTokenUpdate(31) END;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      endPos := ORS.Pos();
       ORS.Get(sym);
       WHILE sym = ORS.ident DO
-        ORS.CopyId(id); ORS.Get(sym); CheckExport(expo);
+        ORS.CopyId(id); ORB.NewObj(obj, id, modid, ORB.Typ, LSPhConstants.SynType); typePos := ORS.Pos();
+        ORS.ModuleTagPP(LSPhConstants.DefinitionListStart, endPos);
+        ORS.ModuleTagP(LSPhConstants.DefinitionListValue);
+        ORS.ClassifyIdent(LSPhConstants.SynType, ORS.Pos(), modid); ORS.Get(sym); CheckExport(expo);
         IF sym = ORS.eql THEN ORS.Get(sym) ELSE ORS.Mark("=?") END ;
         Type(tp, expo);
-        ORB.NewObj(obj, id, ORB.Typ); obj.type := tp; obj.expo := expo; obj.lev := level;
+        obj.type := tp; obj.expo := expo; obj.lev := level;
         IF tp.typobj = NIL THEN tp.typobj := obj END ;
         IF expo & (obj.type.form = ORB.Record) THEN obj.exno := exno; INC(exno) ELSE obj.exno := 0 END ;
         IF tp.form IN {ORB.Record, ORB.Array} THEN
           ptbase := pbsList;  (*check whether this is base of a pointer type; search and fixup*)
           WHILE ptbase # NIL DO
-            IF obj.name = ptbase.name THEN ptbase.type.base := obj.type END ;
+            IF obj.name = ptbase.name THEN
+              IF ORS.lspMode = LSPhConstants.GetModuleInfo THEN
+                RS232.Send(LSPhConstants.ForwardPointerFixup);
+                RS232.SendIntRaw(ptbase.symPos);
+                RS232.SendIntRaw(typePos);
+              END;
+              ptbase.type.base := obj.type
+            END ;
             ptbase := ptbase.next
           END
         END ;
+        endPos := ORS.Pos();
+        ORS.ModuleTagP(LSPhConstants.DefinitionListEnd);
         Check(ORS.semicolon, "; missing")
       END
+      ;ORS.ModuleTagPP(LSPhConstants.DeclarationBlockEnd, endPos);
     END ;
     IF sym = ORS.var THEN
+      ORS.ModuleTagPP(LSPhConstants.DeclarationBlockStart, ORS.Pos() - 3);
+      IF level = 0 THEN ORS.FormatTokenUpdate(31) ELSE ORS.FormatTokenUpdate(21) END;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      endPos := ORS.Pos();
       ORS.Get(sym);
       WHILE sym = ORS.ident DO
-        IdentList(ORB.Var, first); obj := first; expo := TRUE;
+        ORS.ModuleTagPP(LSPhConstants.DefinitionListStart, endPos);
+        IdentList(ORB.Var, LSPhConstants.SynVariable, first, FALSE, FALSE); obj := first; expo := TRUE;
         WHILE (obj # NIL) & expo DO expo := obj.expo; obj := obj.next END ;
         Type(tp, expo);
         IF (tp.form = ORB.Array) & (tp.len < 0) THEN ORS.Mark("open array not allowed") END ;
@@ -1004,8 +1099,11 @@
           IF obj.expo THEN obj.exno := exno; INC(exno) END ;
           obj := obj.next
         END ;
+        endPos := ORS.Pos();
+        ORS.ModuleTagP(LSPhConstants.DefinitionListEnd);
         Check(ORS.semicolon, "; missing")
       END
+      ;ORS.ModuleTagPP(LSPhConstants.DeclarationBlockEnd, endPos);
     END ;
     varsize := (varsize + 3) DIV 4 * 4;
     ptbase := pbsList;
@@ -1020,7 +1118,7 @@
     VAR obj: ORB.Object;
   BEGIN rec := NIL;
     IF sym = ORS.var THEN ORS.Get(sym); class := ORB.Par ELSE class := ORB.Var END ;
-    IF sym = ORS.ident THEN ORS.CopyId(name); ORS.Get(sym) ELSE ORS.Mark("ident?") END ;
+    IF sym = ORS.ident THEN ORS.CopyId(name); ORS.ClassifyIdent(LSPhConstants.SynParameter, ORS.Pos(), modid); ORS.Get(sym) ELSE ORS.Mark("ident?") END ;
     Check(ORS.colon, ": expected");
     IF sym = ORS.ident THEN
       qualident(obj);
@@ -1042,10 +1140,10 @@
     VAR proc, redef, obj: ORB.Object;
       type, typ, rec: ORB.Type;
       procid, recid: ORS.Ident;
-      parblksize: LONGINT; form, class: INTEGER;
-      int, body, expo: BOOLEAN;
+      parblksize, procNamePos, defEndPos: LONGINT; form, class: INTEGER;
+      int, body, newproc, expo: BOOLEAN;
 
-    PROCEDURE Body(proc: ORB.Object; parblksize: LONGINT; int: BOOLEAN);
+    PROCEDURE Body(proc: ORB.Object; parblksize, procNamePos: LONGINT; int: BOOLEAN);
       VAR obj: ORB.Object; x: ORG.Item; locblksize: LONGINT;
     BEGIN Check(ORS.semicolon, "no ;"); locblksize := parblksize;
       Declarations(locblksize); obj := ORB.topScope; proc.type.dsc := obj.next;
@@ -1054,23 +1152,39 @@
       ORG.FixLinkMixed(proc.type.len);  (*fix forward references generated in ORG*)
       proc.val := ORG.Here() * 4; proc.type.dsc := obj.next; DEC(fc);
       ORG.Enter(parblksize, locblksize, int);
-      IF sym = ORS.begin THEN ORS.Get(sym); StatSequence END ;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+      IF sym = ORS.begin THEN
+        ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+        ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+        ORS.Get(sym); StatSequence
+      END ;
       IF proc.type.base.form # ORB.NoTyp THEN  (*function procedure*)
         IF obj.lev = 0 THEN ORS.Mark("function without result")
         ELSIF ~return OR (obj.lev # 1) THEN CheckRetro
         END
       ELSIF obj.lev > 0 THEN CheckRetro
       END ;
-      ORG.Return(proc.type.base.form, x, locblksize, int); Check(ORS.end, "no END");
+      ORG.Return(proc.type.base.form, x, locblksize, int);
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      Check(ORS.end, "no END");
       IF sym = ORS.ident THEN
-        IF ORS.id # proc.name THEN ORS.Mark("no match") END ;
+        IF ORS.id # proc.name THEN ORS.AddCompletion(LSPhConstants.SynProcedure, proc.name); ORS.Mark("no match") END ;
+        ORS.ClassifyIdent(LSPhConstants.SynProcedure, procNamePos, modid);
+        ORS.ModuleTag(LSPhConstants.DefinitionRepeat);
         ORS.Get(sym)
       ELSE ORS.Mark("no proc id")
       END
     END Body;
 
-  BEGIN (* ProcedureDecl *) int := FALSE; body := TRUE; rec := NIL; ORS.Get(sym);
-    IF sym = ORS.times THEN (*interrupt*) ORS.Get(sym); int := TRUE
+  BEGIN (* ProcedureDecl *) int := FALSE; newproc := FALSE; body := TRUE; rec := NIL;
+    IF level = 0 THEN ORS.FormatTokenUpdate(31) ELSE ORS.FormatTokenUpdate(21) END;
+    ORS.ModuleTag(LSPhConstants.ProcedureStart);
+    ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+    ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+    ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+    ORS.Get(sym);
+    IF sym = ORS.times THEN (*interrupt*) ORS.FormatTokenUpdate(00); ORS.Get(sym); int := TRUE
     ELSIF sym = ORS.arrow THEN (*forward*) ORS.Get(sym); body := FALSE
     END ;
     IF sym = ORS.lparen THEN
@@ -1079,18 +1193,29 @@
     ELSE form := ORB.Proc
     END ;
     IF sym = ORS.ident THEN
-      ORS.CopyId(procid); ORS.Get(sym); CheckExport(expo);
-      IF int THEN parblksize := 12 ELSE parblksize := 4 END ;
-      NEW(type); type.size := ORG.WordSize; type.len := 0; (*len used as heading of fixup chain of forward refs*)
+      ORS.CopyId(procid); procNamePos := ORS.Pos(); ORS.ClassifyIdent(LSPhConstants.SynProcedure, ORS.Pos(), modid);
       IF rec = NIL THEN  (*regular procedure*)
+      IF expo & (type.nofpar = 0) & (type.base = ORB.noType) THEN
+        ORS.ModuleTagH(LSPhConstants.CommandExported)
+      END;
         proc := ORB.FindObj(procid, ORB.topScope.next);
         IF proc = NIL THEN  (*identifier not found in the symbol table*)
-          ORB.NewObj(proc, procid, ORB.Const); INC(fc);
+          ORB.NewObj(proc, procid, modid, ORB.Const, LSPhConstants.SynProcedure); INC(fc); newproc := TRUE
+        END;
+      ELSE (*type-bound procedure*)
+        defEndPos := ORS.Pos()
+      END;
+      ORS.Get(sym);
+      CheckExport(expo);
+      IF int THEN parblksize := 12 ELSE parblksize := 4 END ;
+      NEW(type); type.size := ORG.WordSize; type.len := 0; (*len used as heading of fixup chain of forward refs*)
+      IF rec = NIL THEN  (*regular procedure*)
+        IF newproc THEN
           type.form := ORB.Proc; proc.type := type; proc.val := -1; proc.lev := level; proc.expo := expo;
-          IF expo THEN proc.exno := exno; INC(exno) END
-        END ;
+          IF expo THEN proc.exno := exno; INC(exno) END ;
+        END;
         ORB.OpenScope; INC(level); type.base := ORB.noType;
-        ProcedureType(type, parblksize); type.dsc := ORB.topScope.next  (*formal parameter list*)
+        ProcedureType(type, parblksize, TRUE); type.dsc := ORB.topScope.next  (*formal parameter list*)
       ELSE  (*type-bound procedure*)
         IF rec.base # NIL THEN redef := ORB.FindObj(procid, rec.base.dsc);  (*search in base types of receiver*)
           IF (redef # NIL) & ((redef.class # ORB.Const) OR (redef.type.form # ORB.TProc)) THEN ORS.Mark("mult def") END
@@ -1098,20 +1223,20 @@
         END ;
         proc := ORB.FindFld(procid, rec);  (*search in fields of receiver proper, but not of its base types*)
         IF proc = NIL THEN
-          ORB.NewMethod(rec, proc, redef, procid); INC(fc);
+          ORB.NewMethod(rec, proc, redef, procid, modid, defEndPos); INC(fc);
           IF rec.typobj.val > 0 THEN ORS.Mark("invalid method order") ELSE DisallowMethods(rec.base) END ;
           type.form := ORB.TProc; proc.type := type; proc.val := -1; proc.expo := expo;
           IF expo THEN proc.exno := exno; INC(exno);
             IF ~typ.typobj.expo THEN ORS.Mark("receiver must be exported") END ;
-            procid := "@"; ORB.NewObj(obj, procid, ORB.Const); obj.name[0] := 0X; (*dummy to preserve linear order of exno*)
+            procid := "@"; ORB.NewObj(obj, procid, modid, ORB.Const, LSPhConstants.SynConstant); obj.name[0] := 0X; (*dummy to preserve linear order of exno*)
             obj.type := proc.type; obj.dsc := proc; obj.exno := proc.exno; obj.expo := FALSE
           END
         END ;
         ORB.OpenScope; INC(level); type.base := ORB.noType;
-        ORB.NewObj(obj, recid, class);  (*insert receiver as first parameter*)
+        ORB.NewObj(obj, recid, modid, class, LSPhConstants.SynParameter); ORS.Get(sym);  (*insert receiver as first parameter*)
         obj.type := typ; obj.rdo := FALSE; obj.lev := level; obj.val := parblksize;
         IF typ.form = ORB.Record THEN INC(parblksize, 2*ORG.WordSize) ELSE INC(parblksize, ORG.WordSize) END ;
-        ProcedureType(type, parblksize); type.dsc := ORB.topScope.next; INC(type.nofpar);  (*formal parameter list*)
+        ProcedureType(type, parblksize, TRUE); type.dsc := ORB.topScope.next; INC(type.nofpar);  (*formal parameter list*)
         IF redef # NIL THEN  (*redefined method found*)
           IF redef.expo & typ.typobj.expo & ~proc.expo THEN ORS.Mark("overriding method must be exported")
           ELSIF ~EqualSignatures(redef.type, proc.type) THEN ORS.Mark("must match redefined method")
@@ -1123,26 +1248,34 @@
         ELSIF (proc.expo # expo) OR ~EqualSignatures(proc.type, type) THEN ORS.Mark("must match forward declaration")
         END
       END ;
-      IF body THEN Body(proc, parblksize, int) END ;
+      IF body THEN Body(proc, parblksize, procNamePos, int) END ;
       ORB.CloseScope; DEC(level)
     ELSE ORS.Mark("proc id expected")
     END
+    ; ORS.ModuleTagP(LSPhConstants.ProcedureEnd)
   END ProcedureDecl;
 
   PROCEDURE ImportList;
-    VAR impid, impid1: ORS.Ident;
+    VAR impid, impid1: ORS.Ident; defPos: INTEGER;
   BEGIN
+    ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+    ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
     REPEAT ORS.Get(sym);
       IF sym = ORS.ident THEN
-        ORS.CopyId(impid); ORS.Get(sym);
+        ORS.CopyId(impid); ORS.ClassifyIdent(LSPhConstants.SynModule, 1, impid); defPos := ORS.Pos(); ORS.Get(sym);
         IF sym = ORS.becomes THEN
+          ORS.ModuleTag(LSPhConstants.ImportAlias);
           ORS.Get(sym);
-          IF sym = ORS.ident THEN ORS.CopyId(impid1); ORS.Get(sym)
+          IF sym = ORS.ident THEN ORS.CopyId(impid1); ORS.ClassifyIdent(LSPhConstants.SynModule, 1, impid1); ORS.Get(sym)
           ELSE ORS.Mark("id expected"); impid1 := impid
           END
         ELSE impid1 := impid
         END ;
-        ORB.Import(impid, impid1)
+        IF ORS.lspMode = LSPhConstants.GetModuleInfo THEN
+          RS232.Send(LSPhConstants.ModuleImport);
+          RS232.SendStrRaw(impid1)
+        END;
+        ORB.Import(impid, impid1, modid, defPos)
       ELSE ORS.Mark("id expected")
       END
     UNTIL sym # ORS.comma
@@ -1150,17 +1283,24 @@
 
   PROCEDURE Module;
     VAR key: LONGINT;
-  BEGIN Texts.WriteString(W, "  compiling "); ORS.Get(sym);
+  BEGIN ORS.Get(sym);
     IF sym = ORS.module THEN
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+      ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
       ORS.Get(sym); retro := FALSE;
-      IF sym = ORS.times THEN version := 0; dc := 8; Texts.Write(W, "*"); ORS.Get(sym)
+      IF sym = ORS.times THEN ORS.FormatTokenUpdate(01); version := 0; dc := 8; ORS.Get(sym)
       ELSE dc := 0; version := 1;
-        IF sym = ORS.arrow THEN retro := TRUE; Texts.Write(W, "^"); ORS.Get(sym) END
+        IF sym = ORS.arrow THEN retro := TRUE; ORS.Get(sym) END
       END ;
       ORB.Init; ORB.OpenScope;
       IF sym = ORS.ident THEN
-        ORS.CopyId(modid); ORS.Get(sym);
-        Texts.WriteString(W, modid); Texts.Append(Oberon.Log, W.buf)
+        ORS.CopyId(modid);
+        ORS.ClassifyIdent(LSPhConstants.SynModule, ORS.Pos(), modid);
+        ORS.Get(sym);
+        IF ORS.lspMode = LSPhConstants.GetModuleInfo THEN
+          RS232.Send(LSPhConstants.ModuleName);
+          RS232.SendStrRaw(modid)
+        END
       ELSE ORS.Mark("identifier expected")
       END ;
       Check(ORS.semicolon, "no ;"); level := 0; fc := 0; exno := 1; key := 0; looplev := 0; exitno := 0;
@@ -1169,31 +1309,40 @@
       WHILE sym = ORS.procedure DO ProcedureDecl; Check(ORS.semicolon, "no ;") END ;
       IF fc > 0 THEN ORS.Mark("undefined forward declarations") END ;
       ORG.Header;
-      IF sym = ORS.begin THEN ORS.Get(sym); StatSequence END ;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+      IF sym = ORS.begin THEN
+        ORS.FormatTokenTag(LSPhConstants.OutdentThisLineAndComment);
+        ORS.FormatTokenTag(LSPhConstants.IndentNextLine);
+        ORS.Get(sym); StatSequence
+      END ;
+      ORS.FormatTokenTag(LSPhConstants.OutdentThisLine);
       ORG.Exit;
       IF (sym = ORS.final) & (version # 0) THEN ORG.Final; ORS.Get(sym); StatSequence; ORG.Exit END ;
       Check(ORS.end, "no END");
       IF sym = ORS.ident THEN
-        IF ORS.id # modid THEN ORS.Mark("no match") END ;
+        IF ORS.id # modid THEN ORS.AddCompletion(LSPhConstants.SynModule, modid); ORS.Mark("no match") END ;
+        ORS.ClassifyIdent(LSPhConstants.SynModule, 1, modid);
+        ORS.ModuleTag(LSPhConstants.DefinitionRepeat);
         ORS.Get(sym)
       ELSE ORS.Mark("identifier missing")
       END ;
-      IF sym # ORS.period THEN ORS.Mark("period missing") END ;
-      IF (ORS.errcnt = 0) & (version # 0) THEN
+      IF sym # ORS.period THEN ORS.Mark("period missing") ELSE
+        ORS.Get(sym); IF sym # ORS.eot THEN ORS.Mark("trailing content in file") END
+      END ;
+      IF (ORS.errcnt = 0) & (version # 0) & ((ORS.lspMode = LSPhConstants.GetModuleInfo) OR (ORS.lspMode >= LSPhConstants.CompileSymbolFile)) THEN
         ORB.Export(modid, newSF, key);
-        IF newSF THEN Texts.WriteString(W, " new symbol file") END
+        IF newSF & (ORS.lspMode = LSPhConstants.GetModuleInfo) THEN RS232.Send(LSPhConstants.SymbolFileChanged) END
       END ;
       IF ORS.errcnt = 0 THEN
         ORG.Close(modid, key, exno);
-        Texts.WriteInt(W, ORG.pc, 6); Texts.WriteInt(W, dc, 6); Texts.WriteHex(W, key)
-      ELSE Texts.WriteLn(W); Texts.WriteString(W, "compilation FAILED")
+      ELSE ORS.Mark("compilation FAILED")
       END ;
-      Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
       ORB.CloseScope; pbsList := NIL
     ELSE ORS.Mark("must start with MODULE")
     END
   END Module;
 
+  (*
   PROCEDURE Option(VAR S: Texts.Scanner);
   BEGIN newSF := FALSE;
     IF S.nextCh = "/" THEN
@@ -1233,9 +1382,22 @@
     END ;
     Oberon.Collect(0); Oberon.Return(res)
   END Compile;
+  *)
+
+  PROCEDURE AnalyzeText*(VAR T: Texts.Text; beg: INTEGER);
+  BEGIN
+    ORS.Init(T, beg); newSF := TRUE; Module
+  END AnalyzeText;
+
+  PROCEDURE Analyze*;
+    VAR beg, end, time: LONGINT;
+      T: Texts.Text;
+  BEGIN
+    NEW(T); Texts.Open(T, "Tmp.Tmp"); AnalyzeText(T, 0)
+  END Analyze;
 
-BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OR Retro Compiler  8.3.2020 / AP 11.1.22");
-  Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
+BEGIN
   NEW(dummy); dummy.class := ORB.Var; dummy.type := ORB.intType;
-  expression := expression0; Type := Type0; FormalType := FormalType0
-END ORP.
+  dummy.lspClass := LSPhConstants.SynVariable; dummy.defEndPos := -1;
+  expression1 := expression0; Type := Type0; FormalType := FormalType0
+END LSPhORP.
